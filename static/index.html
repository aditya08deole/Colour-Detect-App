<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Color Picker Pro - Advanced Color Detector</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ðŸŽ¨</text></svg>">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/@panzoom/panzoom@4.5.1/dist/panzoom.min.js"></script>
    <link rel="stylesheet" href="/static/style.css">
</head>
<body>

    <div class="app-container">
        <aside class="sidebar">
            <div>
                <h1 class="logo">Color<span>Picker</span> Pro</h1>
                <p>Perceptually accurate color detection.</p>
            </div>
            <div id="results-container">
                <h2>Current Selection</h2>
                <div id="results-card" class="results-card">
                    <div class="results-header">
                        <div id="color-box"></div>
                        <div id="color-details">
                            <p><strong>Name:</strong> <span id="colorName">N/A</span></p>
                            <p><strong>Hex:</strong> <span id="hexCode">N/A</span> <button class="copy-btn" onclick="colorApp.copyToClipboard('#hexCode', this)">copy</button></p>
                            <p><strong>RGB:</strong> <span id="rgbValue">N/A</span> <button class="copy-btn" onclick="colorApp.copyToClipboard('#rgbValue', this)">copy</button></p>
                        </div>
                    </div>
                    <div id="palette-container" class="palette-container"></div>
                </div>
            </div>
            <div id="history-container">
                <div class="history-header">
                    <h2>History</h2>
                    <span id="clear-history">Clear</span>
                </div>
                <ul id="history-list">
                    <li id="history-empty-state" style="justify-content: center; opacity: 0.6;">No colors picked yet.</li>
                </ul>
            </div>
             <div class="theme-switch-wrapper">
                <label class="theme-switch" for="theme-toggle">
                    <input type="checkbox" id="theme-toggle">
                    <div class="slider round"></div>
                </label>
                <em>Dark Mode</em>
            </div>
        </aside>

        <main class="main-content">
            <div class="canvas-wrapper">
                <div class="controls-header">
                    <label for="imageLoader" id="upload-label" class="upload-label">
                        <span id="upload-text">Upload New Image</span>
                        <div id="upload-loader" class="loader" style="display: none;"></div>
                    </label>
                    <div class="zoom-controls">
                        <button id="zoom-in" title="Zoom In" aria-label="Zoom In"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg></button>
                        <button id="zoom-out" title="Zoom Out" aria-label="Zoom Out"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="5" y1="12" x2="19" y2="12"></line></svg></button>
                        <button id="reset-zoom" title="Reset" aria-label="Reset Zoom"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M2.5 2v6h6M21.5 22v-6h-6"/><path d="M22 11.5A10 10 0 0 0 3.5 12.5"/><path d="M2 12.5a10 10 0 0 0 18.5-1"/></svg></button>
                    </div>
                </div>
                <div class="canvas-container" id="canvas-container">
                    <div id="upload-area" class="upload-area">
                        <p>Drag & Drop Image Here</p>
                        <input type="file" id="imageLoader" accept="image/png, image/jpeg, image/webp">
                    </div>
                    <canvas id="imageCanvas"></canvas>
                    <canvas id="pixelGridCanvas"></canvas>
                    <div id="loupe" style="display: none;"></div>
                    <div id="navigator"><div id="navigator-view"></div></div>
                    <div id="loader-container" class="loader-container" style="display:none;"><div class="loader" style="width:50px; height:50px;"></div></div>
                </div>
            </div>
        </main>
    </div>
    
    <div id="toast-container"></div>
    <footer>
        &copy; 2025 Made by Adi Deole &bull; <a href="mailto:adityadeole08@gmail.com">adityadeole08@gmail.com</a>
    </footer>

    <script>
        const colorApp = {
            // DOM Elements
            imageLoader: document.getElementById('imageLoader'),
            uploadArea: document.getElementById('upload-area'),
            uploadLabel: document.getElementById('upload-label'),
            uploadText: document.getElementById('upload-text'),
            uploadLoader: document.getElementById('upload-loader'),
            canvas: document.getElementById('imageCanvas'),
            canvasContainer: document.getElementById('canvas-container'),
            ctx: document.getElementById('imageCanvas').getContext('2d'),
            pixelGridCanvas: document.getElementById('pixelGridCanvas'),
            pixelGridCtx: document.getElementById('pixelGridCanvas').getContext('2d'),
            loaderContainer: document.getElementById('loader-container'),
            resultsCard: document.getElementById('results-card'),
            colorBox: document.getElementById('color-box'),
            colorNameSpan: document.getElementById('colorName'),
            hexCodeSpan: document.getElementById('hexCode'),
            rgbValueSpan: document.getElementById('rgbValue'),
            historyList: document.getElementById('history-list'),
            historyEmptyState: document.getElementById('history-empty-state'),
            clearHistoryBtn: document.getElementById('clear-history'),
            loupe: document.getElementById('loupe'),
            navigator: document.getElementById('navigator'),
            navigatorView: document.getElementById('navigator-view'),
            toastContainer: document.getElementById('toast-container'),
            themeToggle: document.getElementById('theme-toggle'),
            paletteContainer: document.getElementById('palette-container'),
            
            // State
            currentImageFile: null,
            panzoomInstance: null,
            originalImage: null,
            colorHistory: [],
            isPanning: false,
            lastMouseEvent: null,
            MAX_IMAGE_DIMENSION: 1920,

            init() {
                this.imageLoader.addEventListener('change', (e) => this.handleFiles(e.target.files));
                this.setupDragAndDrop();
                this.setupZoomControls();
                this.canvas.addEventListener('click', (e) => this.handleCanvasClick(e));
                
                this.canvas.addEventListener('mousemove', this.debounce((e) => {
                    this.lastMouseEvent = e;
                    this.updateLoupe(e);
                }, 5));

                this.canvas.addEventListener('mouseenter', () => { if(this.originalImage) this.loupe.style.display = 'block'; });
                this.canvas.addEventListener('mouseleave', () => { this.loupe.style.display = 'none'; });

                this.themeToggle.addEventListener('change', () => this.toggleTheme());
                if (localStorage.getItem('theme') === 'dark') {
                    this.themeToggle.checked = true;
                    document.body.classList.add('dark-mode');
                }

                window.addEventListener('keydown', (e) => this.handleKeyDown(e));
                window.addEventListener('keyup', (e) => this.handleKeyUp(e));
                this.clearHistoryBtn.addEventListener('click', () => this.clearHistory());
            },

            debounce(func, delay) {
                let timeout;
                return function(...args) {
                    const context = this;
                    clearTimeout(timeout);
                    timeout = setTimeout(() => func.apply(context, args), delay);
                };
            },

            handleKeyDown(e) {
                if (e.code === 'Space' && this.originalImage) {
                    e.preventDefault();
                    if (this.isPanning) return;
                    this.isPanning = true;
                    this.canvas.style.cursor = 'grab';
                    this.panzoomInstance.setOptions({ disablePan: false });
                }
            },
            
            handleKeyUp(e) {
                if (e.code === 'Space' && this.originalImage) {
                    this.isPanning = false;
                    this.canvas.style.cursor = 'crosshair';
                    this.panzoomInstance.setOptions({ disablePan: true });
                }
            },

            setupDragAndDrop() {
                const preventDefaults = e => { e.preventDefault(); e.stopPropagation(); };
                ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => this.uploadArea.addEventListener(eventName, preventDefaults, false));
                ['dragenter', 'dragover'].forEach(eventName => this.uploadArea.addEventListener(eventName, () => this.uploadArea.classList.add('dragover'), false));
                ['dragleave', 'drop'].forEach(eventName => this.uploadArea.addEventListener(eventName, () => this.uploadArea.classList.remove('dragover'), false));
                this.uploadArea.addEventListener('drop', (e) => this.handleFiles(e.dataTransfer.files), false);
            },

            setupZoomControls() {
                const zoomOptions = { animate: true };
                document.getElementById('zoom-in').addEventListener('click', () => this.panzoomInstance?.zoomIn(zoomOptions));
                document.getElementById('zoom-out').addEventListener('click', () => this.panzoomInstance?.zoomOut(zoomOptions));
                document.getElementById('reset-zoom').addEventListener('click', () => this.panzoomInstance?.reset(zoomOptions));
            },

            handleFiles(files) {
                const file = files[0];
                if (!file || !file.type.startsWith('image/')) return;

                this.uploadLabel.setAttribute('disabled', true);
                this.uploadText.textContent = 'Processing...';
                this.uploadLoader.style.display = 'block';

                this.resizeImage(file, (resizedBlob, resizedDataUrl) => {
                    if (!resizedBlob || !resizedDataUrl) {
                        this.showToast('Error: Could not process image.', true);
                        this.resetUI();
                        return;
                    }
                    
                    this.currentImageFile = resizedBlob;
                    
                    this.originalImage = new Image();
                    this.originalImage.onerror = () => {
                        this.showToast('Error: Could not load image file.', true);
                        this.resetUI();
                    };
                    this.originalImage.onload = () => {
                        this.canvas.width = this.originalImage.width;
                        this.canvas.height = this.originalImage.height;
                        this.pixelGridCanvas.width = this.originalImage.width;
                        this.pixelGridCanvas.height = this.originalImage.height;
                        
                        this.ctx.drawImage(this.originalImage, 0, 0);
                        
                        this.uploadArea.style.display = 'none';
                        this.canvas.style.display = 'block';
                        
                        if (this.panzoomInstance) this.panzoomInstance.destroy();
                        this.panzoomInstance = Panzoom(this.canvas, {
                            maxScale: 30,
                            canvas: true,
                            disablePan: true 
                        });
                        
                        this.canvasContainer.addEventListener('wheel', (e) => {
                            e.preventDefault();
                            this.panzoomInstance.zoomWithWheel(e, { 
                                animate: true,
                                focal: { x: e.clientX, y: e.clientY }
                            });
                        });

                        this.canvas.addEventListener('panzoomzoom', (e) => {
                            this.updateNavigator();
                            this.drawPixelGrid();
                            if (this.lastMouseEvent) this.updateLoupe(this.lastMouseEvent);
                        });
                        this.canvas.addEventListener('panzoompan', (e) => {
                            this.updateNavigator();
                            this.drawPixelGrid();
                        });
                        
                        this.setupNavigator();
                        this.resetUploadButton();
                    };
                    this.originalImage.src = resizedDataUrl;
                });
            },

            resizeImage(file, callback) {
                const reader = new FileReader();
                reader.onerror = () => {
                    callback(null, null);
                };
                reader.onload = (e) => {
                    const img = new Image();
                    img.onerror = () => {
                        callback(null, null);
                    };
                    img.onload = () => {
                        let { width, height } = img;
                        if (width > height) {
                            if (width > this.MAX_IMAGE_DIMENSION) {
                                height *= this.MAX_IMAGE_DIMENSION / width;
                                width = this.MAX_IMAGE_DIMENSION;
                            }
                        } else {
                            if (height > this.MAX_IMAGE_DIMENSION) {
                                width *= this.MAX_IMAGE_DIMENSION / height;
                                height = this.MAX_IMAGE_DIMENSION;
                            }
                        }
                        const canvas = document.createElement('canvas');
                        canvas.width = width;
                        canvas.height = height;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0, width, height);
                        
                        const dataUrl = canvas.toDataURL(file.type);
                        canvas.toBlob(blob => {
                            callback(blob, dataUrl);
                        }, file.type, 0.9);
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            },
            
            resetUI() {
                this.uploadArea.style.display = 'flex';
                this.canvas.style.display = 'none';
                this.navigator.style.display = 'none';
                this.resetUploadButton();
            },
            
            resetUploadButton() {
                this.uploadLabel.removeAttribute('disabled');
                this.uploadText.textContent = 'Upload New Image';
                this.uploadLoader.style.display = 'none';
            },

            handleCanvasClick(e) {
                if (!this.currentImageFile || !this.panzoomInstance || this.isPanning) return;
                const rect = this.canvas.getBoundingClientRect();
                const pan = this.panzoomInstance.getPan();
                const scale = this.panzoomInstance.getScale();
                const x = (e.clientX - rect.left - pan.x) / scale;
                const y = (e.clientY - rect.top - pan.y) / scale;
                this.loaderContainer.style.display = 'flex';
                const formData = new FormData();
                formData.append('image', this.currentImageFile);
                formData.append('x', Math.round(x));
                formData.append('y', Math.round(y));
                fetch('/api/detect', { method: 'POST', body: formData })
                    .then(response => response.ok ? response.json() : response.json().then(err => Promise.reject(err)))
                    .then(data => {
                        this.loaderContainer.style.display = 'none';
                        this.displayResults(data);
                        this.addToHistory(data);
                    })
                    .catch(error => {
                        this.loaderContainer.style.display = 'none';
                        this.showToast(error.detail || 'Could not detect color.', true);
                    });
            },

            updateLoupe(e) {
                if (!this.originalImage || !this.panzoomInstance) return;
                const rect = this.canvas.getBoundingClientRect();
                const pan = this.panzoomInstance.getPan();
                const scale = this.panzoomInstance.getScale();
                const imgX = (e.clientX - rect.left - pan.x) / scale;
                const imgY = (e.clientY - rect.top - pan.y) / scale;
                
                this.loupe.style.left = `${e.clientX - 75}px`;
                this.loupe.style.top = `${e.clientY - 75}px`;
                
                const zoomFactor = 4;
                
                this.loupe.style.backgroundSize = `${this.originalImage.width * zoomFactor}px ${this.originalImage.height * zoomFactor}px`;
                this.loupe.style.backgroundPosition = `-${imgX * zoomFactor - 75}px -${imgY * zoomFactor - 75}px`;
                this.loupe.style.backgroundImage = `url(${this.originalImage.src})`;
            },
            
            drawPixelGrid() {
                if (!this.panzoomInstance) return;
                const pan = this.panzoomInstance.getPan();
                const scale = this.panzoomInstance.getScale();
                const ctx = this.pixelGridCtx;
                
                ctx.clearRect(0, 0, this.pixelGridCanvas.width, this.pixelGridCanvas.height);
                
                if (scale < 8) return;

                ctx.save();
                ctx.lineWidth = 1; // Grid lines will be scaled down
                ctx.strokeStyle = document.body.classList.contains('dark-mode') ? 'rgba(255, 255, 255, 0.2)' : 'rgba(0, 0, 0, 0.2)';

                // We don't need to transform the grid canvas, just draw on it in the correct place
                const left = pan.x % scale;
                const top = pan.y % scale;

                for (let x = left; x < this.pixelGridCanvas.width; x += scale) {
                    ctx.beginPath();
                    ctx.moveTo(x + 0.5, 0);
                    ctx.lineTo(x + 0.5, this.pixelGridCanvas.height);
                    ctx.stroke();
                }
                for (let y = top; y < this.pixelGridCanvas.height; y += scale) {
                    ctx.beginPath();
                    ctx.moveTo(0, y + 0.5);
                    ctx.lineTo(this.pixelGridCanvas.width, y + 0.5);
                    ctx.stroke();
                }
                ctx.restore();
            },

            setupNavigator() {
                this.navigator.style.display = 'block';
                this.navigator.style.backgroundImage = `url(${this.originalImage.src})`;
                this.updateNavigator();
            },

            updateNavigator() {
                if (!this.originalImage || !this.panzoomInstance) return;
                const pan = this.panzoomInstance.getPan();
                const scale = this.panzoomInstance.getScale();
                const containerRect = this.canvasContainer.getBoundingClientRect();
                const navRect = this.navigator.getBoundingClientRect();
                
                if (navRect.width === 0) return; // Don't calculate if navigator is hidden
                
                const viewWidth = containerRect.width / scale;
                const viewHeight = containerRect.height / scale;
                const navScale = navRect.width / this.originalImage.width;
                
                this.navigatorView.style.width = `${viewWidth * navScale}px`;
                this.navigatorView.style.height = `${viewHeight * navScale}px`;
                this.navigatorView.style.left = `${-pan.x * navScale}px`;
                this.navigatorView.style.top = `${-pan.y * navScale}px`;
            },
            
            displayResults(data) {
                this.colorNameSpan.textContent = data.color_name;
                this.hexCodeSpan.textContent = data.hex_code;
                this.rgbValueSpan.textContent = data.rgb;
                this.colorBox.style.backgroundColor = data.detected_rgb;
                this.resultsCard.classList.add('visible');
                const [r, g, b] = data.rgb.split(',').map(Number);
                fetch(`/api/palette?r=${r}&g=${g}&b=${b}`)
                    .then(res => res.json())
                    .then(paletteData => {
                        this.paletteContainer.innerHTML = '<strong>Shades & Tints:</strong>';
                        const paletteDiv = document.createElement('div');
                        paletteDiv.className = 'palette';
                        const fullPalette = [...paletteData.tints.slice(0, 4), data.detected_rgb, ...paletteData.shades.slice(1)];
                        fullPalette.forEach(color => {
                            const swatch = document.createElement('div');
                            swatch.className = 'palette-swatch';
                            swatch.style.backgroundColor = color;
                            paletteDiv.appendChild(swatch);
                        });
                        this.paletteContainer.appendChild(paletteDiv);
                    });
            },

            addToHistory(data) {
                const isDuplicate = this.colorHistory.some(c => c.hex_code === data.hex_code);
                if (!isDuplicate) {
                    this.colorHistory.unshift(data);
                    if (this.colorHistory.length > 20) this.colorHistory.pop();
                    this.renderHistory();
                }
            },

            renderHistory() {
                if (this.colorHistory.length === 0) {
                    this.historyEmptyState.style.display = 'flex';
                    this.historyList.innerHTML = '';
                } else {
                    this.historyEmptyState.style.display = 'none';
                    this.historyList.innerHTML = '';
                    this.colorHistory.forEach(color => {
                        const li = document.createElement('li');
                        li.innerHTML = `<div class="history-swatch" style="background-color: ${color.detected_rgb};"></div><div class="history-info"><strong>${color.color_name}</strong><br><span>${color.hex_code}</span></div>`;
                        li.onclick = () => this.displayResults(color);
                        this.historyList.appendChild(li);
                    });
                }
            },
            
            clearHistory() {
                this.colorHistory = [];
                this.renderHistory();
                this.showToast('History cleared.');
            },

            showToast(message, isError = false) {
                const toast = document.createElement('div');
                toast.className = 'toast';
                if (isError) toast.classList.add('error');
                toast.textContent = message;
                this.toastContainer.appendChild(toast);
                setTimeout(() => toast.classList.add('show'), 10);
                setTimeout(() => {
                    toast.classList.remove('show');
                    toast.addEventListener('transitionend', () => toast.remove());
                }, 3000);
            },

            copyToClipboard(elementSelector, button) {
                const text = document.querySelector(elementSelector).textContent;
                navigator.clipboard.writeText(text).then(() => {
                    const originalText = button.innerHTML;
                    button.disabled = true;
                    button.innerHTML = 'Copied!';
                    setTimeout(() => {
                        button.innerHTML = originalText;
                        button.disabled = false;
                    }, 2000);
                }, () => this.showToast('Failed to copy text.', true));
            },

            toggleTheme() {
                if (this.themeToggle.checked) {
                    document.body.classList.add('dark-mode');
                    localStorage.setItem('theme', 'dark');
                } else {
                    document.body.classList.remove('dark-mode');
                    localStorage.setItem('theme', 'light');
                }
            }
        };
        
        colorApp.init();
    </script>
</body>
</html>