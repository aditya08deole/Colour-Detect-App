<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Color Picker Pro - Advanced Color Detector</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ðŸŽ¨</text></svg>">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/@panzoom/panzoom@4.5.1/dist/panzoom.min.js"></script>
    <link rel="stylesheet" href="/static/style.css">
</head>
<body>

    <div class="app-container">
        <aside class="sidebar">
            <div>
                <h1 class="logo">Color<span>Picker</span> Pro</h1>
                <p>Perceptually accurate color detection.</p>
            </div>
            <div id="results-container">
                <h2>Current Selection</h2>
                <div id="results-card" class="results-card">
                    <div class="results-header">
                        <div id="color-box"></div>
                        <div id="color-details">
                            <p><strong>Name:</strong> <span id="colorName">N/A</span></p>
                            <p><strong>Hex:</strong> <span id="hexCode">N/A</span> <button class="copy-btn" onclick="colorApp.copyToClipboard('#hexCode', this)">copy</button></p>
                            <p><strong>RGB:</strong> <span id="rgbValue">N/A</span> <button class="copy-btn" onclick="colorApp.copyToClipboard('#rgbValue', this)">copy</button></p>
                        </div>
                    </div>
                    <div id="palette-container" class="palette-container"></div>
                </div>
            </div>
            <div id="history-container">
                <div class="history-header">
                    <h2>History</h2>
                    <span id="clear-history">Clear</span>
                </div>
                <ul id="history-list">
                    <li id="history-empty-state" style="justify-content: center; opacity: 0.6;">No colors picked yet.</li>
                </ul>
            </div>
             <div class="theme-switch-wrapper">
                <label class="theme-switch" for="theme-toggle">
                    <input type="checkbox" id="theme-toggle">
                    <div class="slider round"></div>
                </label>
                <em>Dark Mode</em>
            </div>
        </aside>

        <main class="main-content">
            <div class="canvas-wrapper">
                <div class="controls-header">
                    <label for="imageLoader" id="upload-label" class="upload-label">
                        <span id="upload-text">Upload New Image</span>
                        <div id="upload-loader" class="loader" style="display: none;"></div>
                    </label>
                    <div class="zoom-controls">
                        <button id="zoom-in" title="Zoom In" aria-label="Zoom In"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg></button>
                        <button id="zoom-out" title="Zoom Out" aria-label="Zoom Out"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="5" y1="12" x2="19" y2="12"></line></svg></button>
                        <button id="reset-zoom" title="Reset" aria-label="Reset Zoom"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M2.5 2v6h6M21.5 22v-6h-6"/><path d="M22 11.5A10 10 0 0 0 3.5 12.5"/><path d="M2 12.5a10 10 0 0 0 18.5-1"/></svg></button>
                    </div>
                </div>
                <div class="canvas-container" id="canvas-container">
                    <div id="upload-area" class="upload-area">
                        <p>Drag & Drop Image Here</p>
                        <input type="file" id="imageLoader" accept="image/png, image/jpeg, image/webp">
                    </div>
                    <canvas id="imageCanvas"></canvas>
                    <canvas id="pixelGridCanvas"></canvas> <div id="loupe" style="display: none;"></div>
                    <div id="navigator"><div id="navigator-view"></div></div>
                    <div id="loader-container" class="loader-container" style="display:none;"><div class="loader" style="width:50px; height:50px;"></div></div>
                </div>
            </div>
        </main>
    </div>
    
    <div id="toast-container"></div>
    <footer>
        &copy; 2025 Made by Adi Deole &bull; <a href="mailto:adityadeole08@gmail.com">adityadeole08@gmail.com</a>
    </footer>

    <script>
        const colorApp = {
            // DOM Elements
            // ... (all previous DOM element properties are the same)
            pixelGridCanvas: document.getElementById('pixelGridCanvas'),
            pixelGridCtx: document.getElementById('pixelGridCanvas').getContext('2d'),
            
            // State
            // ... (all previous state properties are the same)
            lastMouseEvent: null, // NEW: To store the last mouse event

            init() {
                this.imageLoader.addEventListener('change', (e) => this.handleFiles(e.target.files));
                this.setupDragAndDrop();
                this.setupZoomControls();
                this.canvas.addEventListener('click', (e) => this.handleCanvasClick(e));
                
                // UPDATED: Mouse move listener now stores the last event
                this.canvas.addEventListener('mousemove', this.debounce((e) => {
                    this.lastMouseEvent = e;
                    this.updateLoupe(e);
                }, 5));

                this.canvas.addEventListener('mouseenter', () => { if(this.originalImage) this.loupe.style.display = 'block'; });
                this.canvas.addEventListener('mouseleave', () => { this.loupe.style.display = 'none'; });

                this.themeToggle.addEventListener('change', () => this.toggleTheme());
                if (localStorage.getItem('theme') === 'dark') {
                    this.themeToggle.checked = true;
                    document.body.classList.add('dark-mode');
                }

                window.addEventListener('keydown', (e) => this.handleKeyDown(e));
                window.addEventListener('keyup', (e) => this.handleKeyUp(e));
                this.clearHistoryBtn.addEventListener('click', () => this.clearHistory());
            },
            
            // ... (debounce, handleKeyDown, handleKeyUp, setupDragAndDrop, setupZoomControls remain the same)

            handleFiles(files) {
                const file = files[0];
                if (file && file.type.startsWith('image/')) {
                    this.uploadLabel.setAttribute('disabled', true);
                    this.uploadText.textContent = 'Processing...';
                    this.uploadLoader.style.display = 'block';

                    this.resizeImage(file, (resizedFile) => {
                        this.currentImageFile = resizedFile;
                        const reader = new FileReader();
                        reader.onload = (event) => {
                            this.originalImage = new Image();
                            this.originalImage.onerror = () => {
                                this.showToast('Error: Could not load image file.', true);
                                this.resetUI();
                            };
                            this.originalImage.onload = () => {
                                // Sync canvas sizes
                                this.canvas.width = this.originalImage.width;
                                this.canvas.height = this.originalImage.height;
                                this.pixelGridCanvas.width = this.originalImage.width;
                                this.pixelGridCanvas.height = this.originalImage.height;
                                
                                this.ctx.drawImage(this.originalImage, 0, 0);
                                
                                this.uploadArea.style.display = 'none';
                                this.canvas.style.display = 'block';
                                
                                if (this.panzoomInstance) this.panzoomInstance.destroy();
                                this.panzoomInstance = Panzoom(this.canvas, {
                                    maxScale: 30, // Increased max zoom
                                    canvas: true,
                                    disablePan: true 
                                });
                                
                                this.canvasContainer.addEventListener('wheel', (e) => {
                                    e.preventDefault();
                                    this.panzoomInstance.zoomWithWheel(e, { 
                                        animate: true,
                                        focal: { x: e.clientX, y: e.clientY }
                                    });
                                });

                                // UPDATED: Pan/Zoom listeners now also handle loupe and grid updates
                                this.canvas.addEventListener('panzoomzoom', (e) => {
                                    this.updateNavigator();
                                    this.drawPixelGrid();
                                    if (this.lastMouseEvent) {
                                        this.updateLoupe(this.lastMouseEvent);
                                    }
                                });
                                this.canvas.addEventListener('panzoompan', (e) => {
                                    this.updateNavigator();
                                    this.drawPixelGrid();
                                });
                                
                                this.setupNavigator();
                                this.resetUploadButton();
                            }
                            this.originalImage.src = event.target.result;
                        }
                        reader.readAsDataURL(resizedFile);
                    });
                }
            },
            
            // ... (resetUI, resetUploadButton, resizeImage, handleCanvasClick remain the same)

            updateLoupe(e) {
                if (!this.originalImage || !this.panzoomInstance) return;
                const rect = this.canvas.getBoundingClientRect();
                const pan = this.panzoomInstance.getPan();
                const scale = this.panzoomInstance.getScale();
                const imgX = (e.clientX - rect.left - pan.x) / scale;
                const imgY = (e.clientY - rect.top - pan.y) / scale;
                
                this.loupe.style.left = `${e.clientX - 75}px`;
                this.loupe.style.top = `${e.clientY - 75}px`;
                
                const zoomFactor = 4; // Loupe's fixed magnification
                
                // UPDATED: Loupe is now independent of the main canvas zoom scale
                this.loupe.style.backgroundSize = `${this.originalImage.width * zoomFactor}px ${this.originalImage.height * zoomFactor}px`;
                this.loupe.style.backgroundPosition = `-${imgX * zoomFactor - 75}px -${imgY * zoomFactor - 75}px`;
                this.loupe.style.backgroundImage = `url(${this.originalImage.src})`;
            },
            
            drawPixelGrid() {
                if (!this.panzoomInstance) return;
                const pan = this.panzoomInstance.getPan();
                const scale = this.panzoomInstance.getScale();
                const ctx = this.pixelGridCtx;
                
                ctx.clearRect(0, 0, this.pixelGridCanvas.width, this.pixelGridCanvas.height);
                
                if (scale < 8) return; // Only show grid when highly zoomed

                ctx.save();
                ctx.lineWidth = 1 / scale; // Keep grid lines thin
                ctx.strokeStyle = 'rgba(128, 128, 128, 0.5)';

                // Apply pan and scale to the grid canvas
                ctx.setTransform(scale, 0, 0, scale, pan.x, pan.y);

                const startX = Math.floor(-pan.x / scale);
                const startY = Math.floor(-pan.y / scale);
                const endX = startX + this.canvasContainer.offsetWidth / scale + 1;
                const endY = startY + this.canvasContainer.offsetHeight / scale + 1;

                for (let x = startX; x < endX; x++) {
                    ctx.beginPath();
                    ctx.moveTo(x + 0.5, startY);
                    ctx.lineTo(x + 0.5, endY);
                    ctx.stroke();
                }
                for (let y = startY; y < endY; y++) {
                    ctx.beginPath();
                    ctx.moveTo(startX, y + 0.5);
                    ctx.lineTo(endX, y + 0.5);
                    ctx.stroke();
                }
                ctx.restore();
            },

            // ... (setupNavigator, updateNavigator, displayResults, addToHistory, renderHistory, clearHistory, showToast, copyToClipboard, toggleTheme remain the same)
        };

        // This is a condensed representation. In the actual file, all JS functions would be present.
        // For brevity, only the new/changed functions are shown in full detail.
        // Assume all other functions from the previous response are included here.
        colorApp.init();
    </script>
</body>
</html>