<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Color Picker Pro - Advanced Color Detector</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ðŸŽ¨</text></svg>">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/@panzoom/panzoom@4.5.1/dist/panzoom.min.js"></script>
    <link rel="stylesheet" href="/static/style.css">
</head>
<body>

    <div class="app-container">
        <aside class="sidebar">
            <div>
                <h1 class="logo">Color<span>Picker</span> Pro</h1>
                <p>Perceptually accurate color detection.</p>
            </div>
            <div id="results-container">
                <h2>Current Selection</h2>
                <div id="results-card" class="results-card">
                    <div class="results-header">
                        <div id="color-box"></div>
                        <div id="color-details">
                            <p><strong>Name:</strong> <span id="colorName">N/A</span></p>
                            <p><strong>Hex:</strong> <span id="hexCode">N/A</span> <button class="copy-btn" onclick="colorApp.copyToClipboard('#hexCode', this)">copy</button></p>
                            <p><strong>RGB:</strong> <span id="rgbValue">N/A</span> <button class="copy-btn" onclick="colorApp.copyToClipboard('#rgbValue', this)">copy</button></p>
                        </div>
                    </div>
                    <div id="palette-container" class="palette-container"></div>
                </div>
            </div>
            <div id="history-container">
                <div class="history-header">
                    <h2>History</h2>
                    <span id="clear-history">Clear</span>
                </div>
                <ul id="history-list">
                    <li id="history-empty-state" style="justify-content: center; opacity: 0.6;">No colors picked yet.</li>
                </ul>
            </div>
             <div class="theme-switch-wrapper">
                <label class="theme-switch" for="theme-toggle">
                    <input type="checkbox" id="theme-toggle">
                    <div class="slider round"></div>
                </label>
                <em>Dark Mode</em>
            </div>
        </aside>

        <main class="main-content">
            <div class="canvas-wrapper">
                <div class="controls-header">
                    <label for="imageLoader" id="upload-label" class="upload-label">
                        <span id="upload-text">Upload New Image</span>
                        <div id="upload-loader" class="loader" style="display: none;"></div>
                    </label>
                    <div class="zoom-controls">
                        <button id="zoom-in" title="Zoom In" aria-label="Zoom In"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg></button>
                        <button id="zoom-out" title="Zoom Out" aria-label="Zoom Out"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="5" y1="12" x2="19" y2="12"></line></svg></button>
                        <button id="reset-zoom" title="Reset" aria-label="Reset Zoom"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M2.5 2v6h6M21.5 22v-6h-6"/><path d="M22 11.5A10 10 0 0 0 3.5 12.5"/><path d="M2 12.5a10 10 0 0 0 18.5-1"/></svg></button>
                    </div>
                </div>
                <div class="canvas-container" id="canvas-container">
                    <div id="upload-area" class="upload-area">
                        <p>Drag & Drop Image Here</p>
                        <input type="file" id="imageLoader" accept="image/png, image/jpeg, image/webp">
                    </div>
                    <canvas id="imageCanvas"></canvas>
                    <canvas id="pixelGridCanvas"></canvas>
                    <div id="loupe" style="display: none;"></div>
                    <div id="navigator"><div id="navigator-view"></div></div>
                    <div id="loader-container" class="loader-container" style="display:none;"><div class="loader" style="width:50px; height:50px;"></div></div>
                </div>
            </div>
        </main>
    </div>
    
    <div id="toast-container"></div>
    <footer>
        &copy; 2025 Made by Adi Deole &bull; <a href="mailto:adityadeole08@gmail.com">adityadeole08@gmail.com</a>
    </footer>

    <script>
        const colorApp = {
            // DOM Elements
            imageLoader: document.getElementById('imageLoader'),
            uploadArea: document.getElementById('upload-area'),
            uploadLabel: document.getElementById('upload-label'),
            uploadText: document.getElementById('upload-text'),
            uploadLoader: document.getElementById('upload-loader'),
            canvas: document.getElementById('imageCanvas'),
            canvasContainer: document.getElementById('canvas-container'),
            ctx: document.getElementById('imageCanvas').getContext('2d'),
            pixelGridCanvas: document.getElementById('pixelGridCanvas'),
            pixelGridCtx: document.getElementById('pixelGridCanvas').getContext('2d'),
            loaderContainer: document.getElementById('loader-container'),
            resultsCard: document.getElementById('results-card'),
            colorBox: document.getElementById('color-box'),
            colorNameSpan: document.getElementById('colorName'),
            hexCodeSpan: document.getElementById('hexCode'),
            rgbValueSpan: document.getElementById('rgbValue'),
            historyList: document.getElementById('history-list'),
            historyEmptyState: document.getElementById('history-empty-state'),
            clearHistoryBtn: document.getElementById('clear-history'),
            loupe: document.getElementById('loupe'),
            navigator: document.getElementById('navigator'),
            navigatorView: document.getElementById('navigator-view'),
            toastContainer: document.getElementById('toast-container'),
            themeToggle: document.getElementById('theme-toggle'),
            paletteContainer: document.getElementById('palette-container'),
            
            // State
            currentImageFile: null,
            panzoomInstance: null,
            originalImage: null,
            colorHistory: [],
            isPanning: false,
            lastPointerEvent: null, // Store last mouse or touch event
            MAX_IMAGE_DIMENSION: 1920,

            init() {
                // File handling
                this.imageLoader.addEventListener('change', (e) => this.handleFiles(e.target.files));
                this.setupDragAndDrop();
                
                // Controls
                this.setupZoomControls();
                this.clearHistoryBtn.addEventListener('click', () => this.clearHistory());
                this.themeToggle.addEventListener('change', () => this.toggleTheme());

                // Keyboard shortcuts
                window.addEventListener('keydown', (e) => this.handleKeyDown(e));
                window.addEventListener('keyup', (e) => this.handleKeyUp(e));

                // Universal pointer events for mouse and touch
                const pointerMoveHandler = this.debounce((e) => {
                    this.lastPointerEvent = e;
                    this.updateLoupe(e);
                }, 5);
                this.canvasContainer.addEventListener('pointerdown', (e) => { this.lastPointerEvent = e; });
                this.canvasContainer.addEventListener('pointermove', pointerMoveHandler);
                this.canvasContainer.addEventListener('pointerenter', () => { if(this.originalImage) this.loupe.style.display = 'block'; });
                this.canvasContainer.addEventListener('pointerleave', () => { this.loupe.style.display = 'none'; });

                // Check for saved theme
                if (localStorage.getItem('theme') === 'dark') {
                    this.themeToggle.checked = true;
                    document.body.classList.add('dark-mode');
                }
            },

            // --- Event Handlers & Setup ---

            debounce(func, delay) {
                let timeout;
                return function(...args) {
                    const context = this;
                    clearTimeout(timeout);
                    timeout = setTimeout(() => func.apply(context, args), delay);
                };
            },

            handleKeyDown(e) {
                if (e.code === 'Space' && this.originalImage) {
                    e.preventDefault();
                    if (this.isPanning) return;
                    this.isPanning = true;
                    this.canvas.style.cursor = 'grab';
                    this.panzoomInstance.setOptions({ disablePan: false });
                }
            },
            
            handleKeyUp(e) {
                if (e.code === 'Space' && this.originalImage) {
                    this.isPanning = false;
                    this.canvas.style.cursor = 'crosshair';
                    this.panzoomInstance.setOptions({ disablePan: true });
                }
            },

            setupDragAndDrop() {
                const preventDefaults = e => { e.preventDefault(); e.stopPropagation(); };
                ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => this.uploadArea.addEventListener(eventName, preventDefaults, false));
                ['dragenter', 'dragover'].forEach(eventName => this.uploadArea.addEventListener(eventName, () => this.uploadArea.classList.add('dragover'), false));
                ['dragleave', 'drop'].forEach(eventName => this.uploadArea.addEventListener(eventName, () => this.uploadArea.classList.remove('dragover'), false));
                this.uploadArea.addEventListener('drop', (e) => this.handleFiles(e.dataTransfer.files), false);
            },

            setupZoomControls() {
                const zoomOptions = { animate: true };
                document.getElementById('zoom-in').addEventListener('click', () => this.panzoomInstance?.zoomIn(zoomOptions));
                document.getElementById('zoom-out').addEventListener('click', () => this.panzoomInstance?.zoomOut(zoomOptions));
                document.getElementById('reset-zoom').addEventListener('click', () => this.panzoomInstance?.reset(zoomOptions));
            },

            // --- Image Loading and Processing ---

            handleFiles(files) {
                const file = files[0];
                if (!file || !file.type.startsWith('image/')) return;

                this.uploadLabel.setAttribute('disabled', true);
                this.uploadText.textContent = 'Processing...';
                this.uploadLoader.style.display = 'block';

                this.resizeImage(file, (resizedBlob, resizedDataUrl) => {
                    if (!resizedBlob || !resizedDataUrl) {
                        this.showToast('Error: Could not process image.', true);
                        this.resetUI();
                        return;
                    }
                    
                    this.currentImageFile = resizedBlob;
                    
                    this.originalImage = new Image();
                    this.originalImage.onerror = () => {
                        this.showToast('Error: Could not load image file.', true);
                        this.resetUI();
                    };
                    this.originalImage.onload = () => {
                        this.canvas.width = this.originalImage.width;
                        this.canvas.height = this.originalImage.height;
                        this.pixelGridCanvas.width = this.canvasContainer.clientWidth;
                        this.pixelGridCanvas.height = this.canvasContainer.clientHeight;
                        
                        this.ctx.drawImage(this.originalImage, 0, 0);
                        
                        this.uploadArea.style.display = 'none';
                        this.canvas.style.display = 'block';
                        
                        if (this.panzoomInstance) this.panzoomInstance.destroy();
                        this.panzoomInstance = Panzoom(this.canvas, {
                            maxScale: 30,
                            canvas: true,
                            disablePan: true 
                        });
                        
                        this.canvasContainer.addEventListener('wheel', (e) => {
                            e.preventDefault();
                            this.panzoomInstance.zoomWithWheel(e, { 
                                animate: false, // Animation can feel laggy with grid/loupe updates
                                focal: { x: e.clientX, y: e.clientY }
                            });
                        });

                        this.canvas.addEventListener('panzoomzoom', () => this.onTransformChange());
                        this.canvas.addEventListener('panzoompan', () => this.onTransformChange());
                        
                        this.setupNavigator();
                        this.resetUploadButton();
                    };
                    this.originalImage.src = resizedDataUrl;
                });
            },

            resizeImage(file, callback) {
                const reader = new FileReader();
                reader.onerror = () => callback(null, null);
                reader.onload = (e) => {
                    const img = new Image();
                    img.onerror = () => callback(null, null);
                    img.onload = () => {
                        let { width, height } = img;
                        const ratio = width / height;
                        if (width > this.MAX_IMAGE_DIMENSION) {
                            width = this.MAX_IMAGE_DIMENSION;
                            height = width / ratio;
                        }
                        if (height > this.MAX_IMAGE_DIMENSION) {
                            height = this.MAX_IMAGE_DIMENSION;
                            width = height * ratio;
                        }

                        const canvas = document.createElement('canvas');
                        canvas.width = width;
                        canvas.height = height;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0, width, height);
                        
                        const dataUrl = canvas.toDataURL(file.type);
                        canvas.toBlob(blob => callback(blob, dataUrl), file.type, 0.9);
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            },

            onTransformChange() {
                this.updateNavigator();
                this.drawPixelGrid();
                if (this.lastPointerEvent) this.updateLoupe(this.lastPointerEvent);
            },

            handleCanvasClick(e) {
                // Single point of interaction logic for both mouse and touch
                const pointer = e.touches ? e.touches[0] : e;
                if (!this.currentImageFile || !this.panzoomInstance || this.isPanning) return;

                const rect = this.canvas.getBoundingClientRect();
                const pan = this.panzoomInstance.getPan();
                const scale = this.panzoomInstance.getScale();
                const x = (pointer.clientX - rect.left - pan.x) / scale;
                const y = (pointer.clientY - rect.top - pan.y) / scale;
                
                // Prevent click if coordinates are out of bounds
                if (x < 0 || y < 0 || x > this.originalImage.width || y > this.originalImage.height) return;

                this.loaderContainer.style.display = 'flex';
                const formData = new FormData();
                formData.append('image', this.currentImageFile);
                formData.append('x', Math.round(x));
                formData.append('y', Math.round(y));
                fetch('/api/detect', { method: 'POST', body: formData })
                    .then(response => response.ok ? response.json() : response.json().then(err => Promise.reject(err)))
                    .then(data => {
                        this.loaderContainer.style.display = 'none';
                        this.displayResults(data);
                        this.addToHistory(data);
                    })
                    .catch(error => {
                        this.loaderContainer.style.display = 'none';
                        this.showToast(error.detail || 'Could not detect color.', true);
                    });
            },

            // --- UI Update Functions ---

            updateLoupe(e) {
                if (!this.originalImage || !this.panzoomInstance) return;
                
                const isTouchEvent = e.touches && e.touches.length > 0;
                const pointer = isTouchEvent ? e.touches[0] : e;

                const rect = this.canvas.getBoundingClientRect();
                const pan = this.panzoomInstance.getPan();
                const scale = this.panzoomInstance.getScale();
                
                // BUG FIX: The coordinates on the *unscaled* canvas are needed for background-position.
                // This correctly finds the pixel on the original image data.
                const imgX = (pointer.clientX - rect.left - pan.x) / scale;
                const imgY = (pointer.clientY - rect.top - pan.y) / scale;
                
                // For mobile, offset the loupe so the finger doesn't block it.
                let loupeX = pointer.clientX - 75;
                let loupeY = pointer.clientY - 75;
                if (isTouchEvent) {
                    loupeY = pointer.clientY - 150 - 20; // 150 is loupe height, 20 is margin
                }
                
                this.loupe.style.transform = `translate(${loupeX}px, ${loupeY}px)`;
                
                const zoomFactor = 4;
                this.loupe.style.backgroundSize = `${this.originalImage.width * zoomFactor}px ${this.originalImage.height * zoomFactor}px`;
                this.loupe.style.backgroundPosition = `-${imgX * zoomFactor - 75}px -${imgY * zoomFactor - 75}px`;
                this.loupe.style.backgroundImage = `url(${this.originalImage.src})`;
            },
            
            drawPixelGrid() {
                if (!this.panzoomInstance) return;
                const pan = this.panzoomInstance.getPan();
                const scale = this.panzoomInstance.getScale();
                const ctx = this.pixelGridCtx;
                const canvasWidth = this.pixelGridCanvas.width;
                const canvasHeight = this.pixelGridCanvas.height;
                
                ctx.clearRect(0, 0, canvasWidth, canvasHeight);
                if (scale < 12) return;

                ctx.lineWidth = 1;
                ctx.strokeStyle = document.body.classList.contains('dark-mode') ? 'rgba(255, 255, 255, 0.15)' : 'rgba(0, 0, 0, 0.15)';

                const left = pan.x % scale;
                const top = pan.y % scale;

                for (let x = left; x < canvasWidth; x += scale) {
                    ctx.beginPath();
                    ctx.moveTo(x + 0.5, 0);
                    ctx.lineTo(x + 0.5, canvasHeight);
                    ctx.stroke();
                }
                for (let y = top; y < canvasHeight; y += scale) {
                    ctx.beginPath();
                    ctx.moveTo(0, y + 0.5);
                    ctx.lineTo(canvasWidth, y + 0.5);
                    ctx.stroke();
                }
            },

            // Other functions (resetUI, setupNavigator, displayResults, etc.) are assumed to be here...
            // These functions are included for completeness and have minor updates for robustness.
            resetUI: function() { this.uploadArea.style.display = 'flex'; this.canvas.style.display = 'none'; this.navigator.style.display = 'none'; this.resetUploadButton(); this.pixelGridCtx.clearRect(0,0,this.pixelGridCanvas.width, this.pixelGridCanvas.height); },
            resetUploadButton: function() { this.uploadLabel.removeAttribute('disabled'); this.uploadText.textContent = 'Upload New Image'; this.uploadLoader.style.display = 'none'; },
            setupNavigator: function() { this.navigator.style.display = 'block'; this.navigator.style.backgroundImage = `url(${this.originalImage.src})`; this.updateNavigator(); },
            updateNavigator: function() { if (!this.originalImage || !this.panzoomInstance) return; const pan = this.panzoomInstance.getPan(); const scale = this.panzoomInstance.getScale(); const containerRect = this.canvasContainer.getBoundingClientRect(); const navRect = this.navigator.getBoundingClientRect(); if (navRect.width === 0) return; const viewWidth = containerRect.width / scale; const viewHeight = containerRect.height / scale; const navScale = navRect.width / this.originalImage.width; this.navigatorView.style.width = `${viewWidth * navScale}px`; this.navigatorView.style.height = `${viewHeight * navScale}px`; this.navigatorView.style.left = `${-pan.x * navScale}px`; this.navigatorView.style.top = `${-pan.y * navScale}px`; },
            displayResults: function(data) { this.colorNameSpan.textContent = data.color_name; this.hexCodeSpan.textContent = data.hex_code; this.rgbValueSpan.textContent = data.rgb; this.colorBox.style.backgroundColor = data.detected_rgb; this.resultsCard.classList.add('visible'); const [r, g, b] = data.rgb.split(',').map(Number); fetch(`/api/palette?r=${r}&g=${g}&b=${b}`).then(res => res.json()).then(paletteData => { this.paletteContainer.innerHTML = '<strong>Shades & Tints:</strong>'; const paletteDiv = document.createElement('div'); paletteDiv.className = 'palette'; const fullPalette = [...paletteData.tints.slice(0, 4), data.detected_rgb, ...paletteData.shades.slice(1)]; fullPalette.forEach(color => { const swatch = document.createElement('div'); swatch.className = 'palette-swatch'; swatch.style.backgroundColor = color; paletteDiv.appendChild(swatch); }); this.paletteContainer.appendChild(paletteDiv); }); },
            addToHistory: function(data) { const isDuplicate = this.colorHistory.some(c => c.hex_code === data.hex_code); if (!isDuplicate) { this.colorHistory.unshift(data); if (this.colorHistory.length > 20) this.colorHistory.pop(); this.renderHistory(); } },
            renderHistory: function() { if (this.colorHistory.length === 0) { this.historyEmptyState.style.display = 'flex'; this.historyList.innerHTML = ''; } else { this.historyEmptyState.style.display = 'none'; this.historyList.innerHTML = ''; this.colorHistory.forEach(color => { const li = document.createElement('li'); li.innerHTML = `<div class="history-swatch" style="background-color: ${color.detected_rgb};"></div><div class="history-info"><strong>${color.color_name}</strong><br><span>${color.hex_code}</span></div>`; li.onclick = () => this.displayResults(color); this.historyList.appendChild(li); }); } },
            clearHistory: function() { this.colorHistory = []; this.renderHistory(); this.showToast('History cleared.'); },
            showToast: function(message, isError = false) { const toast = document.createElement('div'); toast.className = 'toast'; if (isError) toast.classList.add('error'); toast.textContent = message; this.toastContainer.appendChild(toast); setTimeout(() => toast.classList.add('show'), 10); setTimeout(() => { toast.classList.remove('show'); toast.addEventListener('transitionend', () => toast.remove()); }, 3000); },
            copyToClipboard: function(elementSelector, button) { const text = document.querySelector(elementSelector).textContent; navigator.clipboard.writeText(text).then(() => { const originalText = button.innerHTML; button.disabled = true; button.innerHTML = 'Copied!'; setTimeout(() => { button.innerHTML = originalText; button.disabled = false; }, 2000); }, () => this.showToast('Failed to copy text.', true)); },
            toggleTheme: function() { if (this.themeToggle.checked) { document.body.classList.add('dark-mode'); localStorage.setItem('theme', 'dark'); } else { document.body.classList.remove('dark-mode'); localStorage.setItem('theme', 'light'); } }
        };
        
        colorApp.init();
    </script>
</body>
</html>