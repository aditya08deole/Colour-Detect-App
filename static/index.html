<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Color Picker Pro - Advanced Color Detector</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ðŸŽ¨</text></svg>">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/@panzoom/panzoom@4.5.1/dist/panzoom.min.js"></script>
    <link rel="stylesheet" href="/static/style.css">
</head>
<body>

    <div class="app-container">
        <aside class="sidebar">
            <div>
                <h1 class="logo">Color<span>Picker</span> Pro</h1>
                <p>Perceptually accurate color detection.</p>
            </div>
            
            <div id="magnifier-container">
                <h2>Magnifier</h2>
                <div id="magnifier-canvas">
                    <div id="magnifier-crosshair"></div>
                </div>
            </div>

            <div id="results-container">
                <h2>Current Selection</h2>
                <div id="results-card" class="results-card">
                    <div class="results-header">
                        <div id="color-box"></div>
                        <div id="color-details">
                            <p><strong>Name:</strong> <span id="colorName">N/A</span></p>
                            <p><strong>Hex:</strong> <span id="hexCode">N/A</span> <button class="copy-btn" onclick="colorApp.copyToClipboard('#hexCode', this)">copy</button></p>
                            <p><strong>RGB:</strong> <span id="rgbValue">N/A</span> <button class="copy-btn" onclick="colorApp.copyToClipboard('#rgbValue', this)">copy</button></p>
                        </div>
                    </div>
                    <div id="palette-container" class="palette-container"></div>
                </div>
            </div>
            <div id="history-container">
                <div class="history-header">
                    <h2>History</h2>
                    <span id="clear-history">Clear</span>
                </div>
                <ul id="history-list">
                    <li id="history-empty-state" style="justify-content: center; opacity: 0.6;">No colors picked yet.</li>
                </ul>
            </div>
             <div class="theme-switch-wrapper">
                <label class="theme-switch" for="theme-toggle">
                    <input type="checkbox" id="theme-toggle">
                    <div class="slider round"></div>
                </label>
                <em>Dark Mode</em>
            </div>
        </aside>

        <main class="main-content">
            <div class="canvas-wrapper">
                <div class="controls-header">
                    <label for="imageLoader" id="upload-label" class="upload-label">
                        <span id="upload-text">Upload New Image</span>
                        <div id="upload-loader" class="loader" style="display: none;"></div>
                    </label>
                    <div class="zoom-panel">
                        <button id="zoom-out-btn" title="Zoom Out" aria-label="Zoom Out"><svg><line x1="5" y1="12" x2="19" y2="12"></line></svg></button>
                        <input type="range" id="zoom-slider" min="1" max="30" value="1" step="0.1">
                        <input type="number" id="zoom-input" value="100">
                        <button id="zoom-in-btn" title="Zoom In" aria-label="Zoom In"><svg><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg></button>
                        <button id="reset-zoom-btn" title="Reset" aria-label="Reset Zoom"><svg><path d="M2.5 2v6h6M21.5 22v-6h-6"/><path d="M22 11.5A10 10 0 0 0 3.5 12.5"/><path d="M2 12.5a10 10 0 0 0 18.5-1"/></svg></button>
                    </div>
                </div>
                <div class="canvas-container" id="canvas-container">
                    <div id="upload-area" class="upload-area">
                        <p>Drag & Drop Image Here</p>
                        <input type="file" id="imageLoader" accept="image/png, image/jpeg, image/webp">
                    </div>
                    <canvas id="imageCanvas"></canvas>
                    <canvas id="pixelGridCanvas"></canvas>
                    <div id="navigator"><div id="navigator-view"></div></div>
                    <div id="loader-container" class="loader-container" style="display:none;"><div class="loader" style="width:50px; height:50px;"></div></div>
                </div>
            </div>
        </main>
    </div>
    
    <div id="toast-container"></div>
    <footer>
        &copy; 2025 Made by Adi Deole &bull; <a href="mailto:adityadeole08@gmail.com">adityadeole08@gmail.com</a>
    </footer>

    <script>
        const colorApp = {
            // DOM Elements
            imageLoader: document.getElementById('imageLoader'),
            uploadArea: document.getElementById('upload-area'),
            uploadLabel: document.getElementById('upload-label'),
            uploadText: document.getElementById('upload-text'),
            uploadLoader: document.getElementById('upload-loader'),
            canvas: document.getElementById('imageCanvas'),
            canvasContainer: document.getElementById('canvas-container'),
            ctx: document.getElementById('imageCanvas').getContext('2d'),
            pixelGridCanvas: document.getElementById('pixelGridCanvas'),
            pixelGridCtx: document.getElementById('pixelGridCanvas').getContext('2d'),
            loaderContainer: document.getElementById('loader-container'),
            resultsCard: document.getElementById('results-card'),
            colorBox: document.getElementById('color-box'),
            colorNameSpan: document.getElementById('colorName'),
            hexCodeSpan: document.getElementById('hexCode'),
            rgbValueSpan: document.getElementById('rgbValue'),
            historyList: document.getElementById('history-list'),
            historyEmptyState: document.getElementById('history-empty-state'),
            clearHistoryBtn: document.getElementById('clear-history'),
            magnifierCanvas: document.getElementById('magnifier-canvas'),
            navigator: document.getElementById('navigator'),
            navigatorView: document.getElementById('navigator-view'),
            toastContainer: document.getElementById('toast-container'),
            themeToggle: document.getElementById('theme-toggle'),
            paletteContainer: document.getElementById('palette-container'),
            zoomSlider: document.getElementById('zoom-slider'),
            zoomInput: document.getElementById('zoom-input'),
            zoomInBtn: document.getElementById('zoom-in-btn'),
            zoomOutBtn: document.getElementById('zoom-out-btn'),
            resetZoomBtn: document.getElementById('reset-zoom-btn'),
            
            // State
            currentImageFile: null,
            panzoomInstance: null,
            originalImage: null,
            colorHistory: [],
            isPanning: false,
            lastPointerEvent: null,
            MAX_IMAGE_DIMENSION: 1920,
            MAGNIFIER_ZOOM: 8,

            init() {
                // File handling
                this.imageLoader.addEventListener('change', (e) => this.handleFiles(e.target.files));
                this.setupDragAndDrop();
                
                // Controls
                this.setupZoomControls();
                this.clearHistoryBtn.addEventListener('click', () => this.clearHistory());
                this.themeToggle.addEventListener('change', () => this.toggleTheme());

                // Keyboard shortcuts
                window.addEventListener('keydown', (e) => this.handleKeyDown(e));
                window.addEventListener('keyup', (e) => this.handleKeyUp(e));

                // Universal pointer events for mouse and touch
                const pointerMoveHandler = this.debounce((e) => {
                    this.lastPointerEvent = e;
                    this.updateMagnifier(e);
                }, 10);
                this.canvasContainer.addEventListener('pointerdown', (e) => { this.lastPointerEvent = e; });
                this.canvasContainer.addEventListener('pointermove', pointerMoveHandler);
                this.canvasContainer.addEventListener('click', (e) => this.handleCanvasClick(e));

                // Check for saved theme
                if (localStorage.getItem('theme') === 'dark') {
                    this.themeToggle.checked = true;
                    document.body.classList.add('dark-mode');
                }
            },

            // --- Event Handlers & Setup ---
            debounce(func, delay) { let timeout; return function(...args) { const context = this; clearTimeout(timeout); timeout = setTimeout(() => func.apply(context, args), delay); }; },
            handleKeyDown(e) { if (e.code === 'Space' && this.originalImage) { e.preventDefault(); if (this.isPanning) return; this.isPanning = true; this.canvas.style.cursor = 'grab'; this.panzoomInstance.setOptions({ disablePan: false }); } },
            handleKeyUp(e) { if (e.code === 'Space' && this.originalImage) { this.isPanning = false; this.canvas.style.cursor = 'crosshair'; this.panzoomInstance.setOptions({ disablePan: true }); } },
            setupDragAndDrop() { const preventDefaults = e => { e.preventDefault(); e.stopPropagation(); }; ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => this.uploadArea.addEventListener(eventName, preventDefaults, false)); ['dragenter', 'dragover'].forEach(eventName => this.uploadArea.addEventListener(eventName, () => this.uploadArea.classList.add('dragover'), false)); ['dragleave', 'drop'].forEach(eventName => this.uploadArea.addEventListener(eventName, () => this.uploadArea.classList.remove('dragover'), false)); this.uploadArea.addEventListener('drop', (e) => this.handleFiles(e.dataTransfer.files), false); },

            setupZoomControls() {
                this.zoomInBtn.addEventListener('click', () => this.panzoomInstance?.zoomIn({ animate: true }));
                this.zoomOutBtn.addEventListener('click', () => this.panzoomInstance?.zoomOut({ animate: true }));
                this.resetZoomBtn.addEventListener('click', () => this.panzoomInstance?.reset({ animate: true }));

                this.zoomSlider.addEventListener('input', (e) => {
                    const scale = parseFloat(e.target.value);
                    this.panzoomInstance.zoom(scale, { animate: false });
                });

                this.zoomInput.addEventListener('change', (e) => {
                    const percentage = parseFloat(e.target.value);
                    if (!isNaN(percentage)) {
                        this.panzoomInstance.zoom(percentage / 100, { animate: true });
                    }
                });
            },

            // --- Image Loading and Processing ---
            handleFiles(files) {
                const file = files[0];
                if (!file || !file.type.startsWith('image/')) return;
                this.uploadLabel.setAttribute('disabled', true);
                this.uploadText.textContent = 'Processing...';
                this.uploadLoader.style.display = 'block';

                this.resizeImage(file, (resizedBlob, resizedDataUrl) => {
                    if (!resizedBlob || !resizedDataUrl) { this.showToast('Error: Could not process image.', true); this.resetUI(); return; }
                    this.currentImageFile = resizedBlob;
                    this.originalImage = new Image();
                    this.originalImage.onerror = () => { this.showToast('Error: Could not load image file.', true); this.resetUI(); };
                    this.originalImage.onload = () => {
                        this.canvas.width = this.originalImage.width;
                        this.canvas.height = this.originalImage.height;
                        this.pixelGridCanvas.width = this.canvasContainer.clientWidth;
                        this.pixelGridCanvas.height = this.canvasContainer.clientHeight;
                        this.ctx.drawImage(this.originalImage, 0, 0);
                        this.uploadArea.style.display = 'none';
                        this.canvas.style.display = 'block';
                        
                        if (this.panzoomInstance) this.panzoomInstance.destroy();
                        this.panzoomInstance = Panzoom(this.canvas, { maxScale: 30, canvas: true, disablePan: true });
                        
                        this.canvasContainer.addEventListener('wheel', (e) => {
                            e.preventDefault();
                            this.panzoomInstance.zoomWithWheel(e, { animate: false });
                        });

                        this.canvas.addEventListener('panzoomzoom', (e) => this.onTransformChange(e));
                        this.canvas.addEventListener('panzoompan', () => this.onTransformChange());
                        
                        this.setupNavigator();
                        this.resetUploadButton();
                        this.onTransformChange();
                    };
                    this.originalImage.src = resizedDataUrl;
                });
            },

            resizeImage(file, callback) {
                const reader = new FileReader();
                reader.onerror = () => callback(null, null);
                reader.onload = (e) => {
                    const img = new Image();
                    img.onerror = () => callback(null, null);
                    img.onload = () => {
                        let { width, height } = img;
                        const ratio = width / height;
                        if (width > this.MAX_IMAGE_DIMENSION) { width = this.MAX_IMAGE_DIMENSION; height = width / ratio; }
                        if (height > this.MAX_IMAGE_DIMENSION) { height = this.MAX_IMAGE_DIMENSION; width = height * ratio; }
                        const canvas = document.createElement('canvas');
                        canvas.width = width;
                        canvas.height = height;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0, width, height);
                        const dataUrl = canvas.toDataURL(file.type);
                        canvas.toBlob(blob => callback(blob, dataUrl), file.type, 0.9);
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            },

            onTransformChange(e) {
                this.updateNavigator();
                this.drawPixelGrid();
                if (this.lastPointerEvent) this.updateMagnifier(this.lastPointerEvent);
                
                const scale = this.panzoomInstance.getScale();
                this.zoomSlider.value = scale;
                this.zoomInput.value = Math.round(scale * 100);
            },

            handleCanvasClick(e) {
                const pointer = e.touches ? e.touches[0] : e;
                if (!this.currentImageFile || !this.panzoomInstance || this.isPanning) return;
                const rect = this.canvasContainer.getBoundingClientRect(); // Use container for stable reference
                const pan = this.panzoomInstance.getPan();
                const scale = this.panzoomInstance.getScale();
                const x = (pointer.clientX - rect.left - pan.x) / scale;
                const y = (pointer.clientY - rect.top - pan.y) / scale;
                if (x < 0 || y < 0 || x > this.originalImage.width || y > this.originalImage.height) return;

                this.loaderContainer.style.display = 'flex';
                const formData = new FormData();
                formData.append('image', this.currentImageFile);
                formData.append('x', Math.round(x));
                formData.append('y', Math.round(y));
                fetch('/api/detect', { method: 'POST', body: formData })
                    .then(response => response.ok ? response.json() : response.json().then(err => Promise.reject(err)))
                    .then(data => { this.loaderContainer.style.display = 'none'; this.displayResults(data); this.addToHistory(data); })
                    .catch(error => { this.loaderContainer.style.display = 'none'; this.showToast(error.detail || 'Could not detect color.', true); });
            },

            // --- UI Update Functions ---
            updateMagnifier(e) {
                if (!this.originalImage || !this.panzoomInstance) return;
                const pointer = e.touches ? e.touches[0] : e;
                
                // BUG FIX: Use the stable container rect for reference, not the moving canvas rect.
                const rect = this.canvasContainer.getBoundingClientRect();
                const pan = this.panzoomInstance.getPan();
                const scale = this.panzoomInstance.getScale();

                // This correctly finds the pixel on the original image data.
                const imgX = (pointer.clientX - rect.left - pan.x) / scale;
                const imgY = (pointer.clientY - rect.top - pan.y) / scale;

                this.magnifierCanvas.style.backgroundImage = `url(${this.originalImage.src})`;
                this.magnifierCanvas.style.backgroundSize = `${this.originalImage.width * this.MAGNIFIER_ZOOM}px ${this.originalImage.height * this.MAGNIFIER_ZOOM}px`;
                
                // Center the background image on the cursor's position
                const bgPosX = -(imgX * this.MAGNIFIER_ZOOM) + (this.magnifierCanvas.offsetWidth / 2);
                const bgPosY = -(imgY * this.MAGNIFIER_ZOOM) + (this.magnifierCanvas.offsetHeight / 2);
                this.magnifierCanvas.style.backgroundPosition = `${bgPosX}px ${bgPosY}px`;
            },
            
            drawPixelGrid() {
                if (!this.panzoomInstance) return;
                const pan = this.panzoomInstance.getPan();
                const scale = this.panzoomInstance.getScale();
                const ctx = this.pixelGridCtx;
                const canvasWidth = this.pixelGridCanvas.width;
                const canvasHeight = this.pixelGridCanvas.height;
                
                ctx.clearRect(0, 0, canvasWidth, canvasHeight);
                if (scale < 12) return;

                ctx.lineWidth = 1;
                ctx.strokeStyle = document.body.classList.contains('dark-mode') ? 'rgba(255, 255, 255, 0.15)' : 'rgba(0, 0, 0, 0.15)';
                const left = pan.x % scale;
                const top = pan.y % scale;

                for (let x = left; x < canvasWidth; x += scale) { ctx.beginPath(); ctx.moveTo(x + 0.5, 0); ctx.lineTo(x + 0.5, canvasHeight); ctx.stroke(); }
                for (let y = top; y < canvasHeight; y += scale) { ctx.beginPath(); ctx.moveTo(0, y + 0.5); ctx.lineTo(canvasWidth, y + 0.5); ctx.stroke(); }
            },

            // Other functions are assumed to be here...
            resetUI: function() { this.uploadArea.style.display = 'flex'; this.canvas.style.display = 'none'; this.navigator.style.display = 'none'; this.resetUploadButton(); this.pixelGridCtx.clearRect(0,0,this.pixelGridCanvas.width, this.pixelGridCanvas.height); },
            resetUploadButton: function() { this.uploadLabel.removeAttribute('disabled'); this.uploadText.textContent = 'Upload New Image'; this.uploadLoader.style.display = 'none'; },
            setupNavigator: function() { this.navigator.style.display = 'block'; this.navigator.style.backgroundImage = `url(${this.originalImage.src})`; this.updateNavigator(); },
            updateNavigator: function() { if (!this.originalImage || !this.panzoomInstance) return; const pan = this.panzoomInstance.getPan(); const scale = this.panzoomInstance.getScale(); const containerRect = this.canvasContainer.getBoundingClientRect(); const navRect = this.navigator.getBoundingClientRect(); if (navRect.width === 0) return; const viewWidth = containerRect.width / scale; const viewHeight = containerRect.height / scale; const navScale = navRect.width / this.originalImage.width; this.navigatorView.style.width = `${viewWidth * navScale}px`; this.navigatorView.style.height = `${viewHeight * navScale}px`; this.navigatorView.style.left = `${-pan.x * navScale}px`; this.navigatorView.style.top = `${-pan.y * navScale}px`; },
            displayResults: function(data) { this.colorNameSpan.textContent = data.color_name; this.hexCodeSpan.textContent = data.hex_code; this.rgbValueSpan.textContent = data.rgb; this.colorBox.style.backgroundColor = data.detected_rgb; this.resultsCard.classList.add('visible'); const [r, g, b] = data.rgb.split(',').map(Number); fetch(`/api/palette?r=${r}&g=${g}&b=${b}`).then(res => res.json()).then(paletteData => { this.paletteContainer.innerHTML = '<strong>Shades & Tints:</strong>'; const paletteDiv = document.createElement('div'); paletteDiv.className = 'palette'; const fullPalette = [...paletteData.tints.slice(0, 4), data.detected_rgb, ...paletteData.shades.slice(1)]; fullPalette.forEach(color => { const swatch = document.createElement('div'); swatch.className = 'palette-swatch'; swatch.style.backgroundColor = color; paletteDiv.appendChild(swatch); }); this.paletteContainer.appendChild(paletteDiv); }); },
            addToHistory: function(data) { const isDuplicate = this.colorHistory.some(c => c.hex_code === data.hex_code); if (!isDuplicate) { this.colorHistory.unshift(data); if (this.colorHistory.length > 20) this.colorHistory.pop(); this.renderHistory(); } },
            renderHistory: function() { if (this.colorHistory.length === 0) { this.historyEmptyState.style.display = 'flex'; this.historyList.innerHTML = ''; } else { this.historyEmptyState.style.display = 'none'; this.historyList.innerHTML = ''; this.colorHistory.forEach(color => { const li = document.createElement('li'); li.innerHTML = `<div class="history-swatch" style="background-color: ${color.detected_rgb};"></div><div class="history-info"><strong>${color.color_name}</strong><br><span>${color.hex_code}</span></div>`; li.onclick = () => this.displayResults(color); this.historyList.appendChild(li); }); } },
            clearHistory: function() { this.colorHistory = []; this.renderHistory(); this.showToast('History cleared.'); },
            showToast: function(message, isError = false) { const toast = document.createElement('div'); toast.className = 'toast'; if (isError) toast.classList.add('error'); toast.textContent = message; this.toastContainer.appendChild(toast); setTimeout(() => toast.classList.add('show'), 10); setTimeout(() => { toast.classList.remove('show'); toast.addEventListener('transitionend', () => toast.remove()); }, 3000); },
            copyToClipboard: function(elementSelector, button) { const text = document.querySelector(elementSelector).textContent; navigator.clipboard.writeText(text).then(() => { const originalText = button.innerHTML; button.disabled = true; button.innerHTML = 'Copied!'; setTimeout(() => { button.innerHTML = originalText; button.disabled = false; }, 2000); }, () => this.showToast('Failed to copy text.', true)); },
            toggleTheme: function() { if (this.themeToggle.checked) { document.body.classList.add('dark-mode'); localStorage.setItem('theme', 'dark'); } else { document.body.classList.remove('dark-mode'); localStorage.setItem('theme', 'light'); } }
        };
        
        colorApp.init();
    </script>
</body>
</html>
